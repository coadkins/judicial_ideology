---
author: Cory
title: 2PL Models with BRMS
date: 11/15/2024
execute:
  cache: FALSE 
  echo: FALSE
output:
  pdf_document:
    includes:
      in_header: 'gt_packages.sty'
---

# Load packages and data

```{r}
suppressPackageStartupMessages(library(brms, quietly = TRUE))
suppressPackageStartupMessages(library(bayesplot, quietly = TRUE))
suppressPackageStartupMessages(library(cmdstanr, quietly = TRUE))
library(DBI)
suppressPackageStartupMessages(library(dplyr, quietly = TRUE))
library(duckdb)
library(gt)
suppressPackageStartupMessages(library(here, quietly = TRUE))
suppressPackageStartupMessages(library(lubridate, quietly = TRUE))
suppressPackageStartupMessages(library(posterior, quietly = TRUE))
suppressPackageStartupMessages(library(qs, quietly = TRUE))

set_cmdstan_path("/home/cory/git/cmdstan/")
```

# Data 
In this case, I exclude cases that result in settlement. I also exclude cases for which the outcome cannot be coded. 
```{r}
db_con <- dbConnect(duckdb(), here("data", "cl_fjc.duckdb"))

# limit the obs. only to appellate court cases 
fjc_cl_coded <- dplyr::tbl(db_con, "fjc_cl_coded_outcome") |>
  # sub-sample 10000 obs.
  slice_sample(n = 10000) |> 
  collect() |>
  mutate(appointment_year = year(commission_date),
         judge_id = judge_split)
```

```{r}
# exclude settlements from counted cases
data <- fjc_cl_coded |>
  group_by(docket_id, court_name) |>
  mutate(case_id = cur_group_id()) |>
  ungroup() |>
  filter(outcome != 2) |>
  mutate(outcome = ifelse(outcome == 1, 0, 1))

data <- data |>
  select(outcome, case_id, judge_id, party_of_appointing_president,
         appointment_year)

dbDisconnect(db_con, shutdown = TRUE)
```

# Rasch model

```{r}
#| echo: TRUE
#| output: FALSE
#| message: FALSE
#| warning: FALSE
#| cache: TRUE
formula_rasch <- bf(outcome ~ 1 + (1 | case_id) + (1 | judge_id))

brms_fit_rasch <- brm(formula = formula_rasch,
                      data = data,
                      family = "bernoulli",
                      backend = "cmdstanr",
                      cores = 4,
                      iter = 4000,
                      warmup = 1000)

qsave(x = brms_fit_rasch, here("data", "brms_fit_rasch.qs"))
```

Priors:

```{r}
#| echo: TRUE
#| output: TRUE
gt(get_prior(brms_fit_rasch)) |> as_latex()
```

Rhat:

```{r}
#| echo: TRUE
rhat <- brms::rhat(brms_fit_rasch) 
tibble(var = names(rhat), rhat = unname(rhat)) |>
  slice_max(rhat, n = 10)
```

Trace Plot
```{r}
#| echo: TRUE
plot(brms_fit_rasch)
```

Posterior Predictive Check:
```{r}
#| echo: TRUE
y_rasch <- mean(standata(brms_fit_rasch)[["Y"]])
yrep_rasch <- rowMeans(posterior_epred(brms_fit_rasch))

hist(yrep_rasch, main = "Posterior Predictive Check", 
xlab = "Posterior Predictive P(Y = 1) (4000 runs)")
abline(v = y_rasch, col = "steelblue", lwd = 2)
legend("topright", legend = "Observed P(Y=1)", col = "steelblue", lty = 1,
       cex = .7)
```


# 2PL model
This fixes the estimates of $\beta_i$ to be positive.

```{r}
#| echo: TRUE
#| output: FALSE
#| message: FALSE
#| warning: FALSE 
#| cache: TRUE
formula_2pl <- bf(outcome ~ 1 + exp(logbeta)*eta,
                  eta ~ 1 + (1 |judge_id), 
                  logbeta ~ 1 + (1 |case_id),
                  nl = TRUE)

priors_2pl <- prior("normal(0, 3)" , class = "b", nlpar = "eta") +
  prior("normal(0, 3)", class = "b", nlpar = "logbeta")

brms_fit_2pl <- brm(formula = formula_2pl,
                        data = data,
                        family = "bernoulli",
                        prior = priors_2pl,
                        backend = "cmdstanr",
                        cores = 4,
                        iter = 2000,
                        warmup = 1000)
                              
qsave(x = brms_fit_2pl, here("data", "brms_fit_2pl.qs"))
```

Priors:

```{r}
#| echo: TRUE
#| output: TRUE 
gt(get_prior(brms_fit_2pl)) |> as_latex()
```

Rhat:

```{r}
#| echo: TRUE
rhat <- brms::rhat(brms_fit_2pl) 
tibble(var = names(rhat), rhat = unname(rhat)) |>
  slice_max(rhat, n = 10)
```

Trace Plot
```{r}
#| echo: TRUE
plot(brms_fit_2pl, variable = c("b_eta_Intercept", "b_logbeta_Intercept"))
```

Posterior Predictive Check:
```{r}
#| echo: TRUE
y_2pl <- mean(standata(brms_fit_2pl)[["Y"]])
yrep_2pl <- rowMeans(posterior_epred(brms_fit_2pl))

hist(yrep_2pl, main = "Posterior Predictive Check", 
xlab = "Posterior Predictive P(Y = 1) (4000 runs)")
abline(v = y_2pl, col = "steelblue", lwd = 2)
legend("topright", legend = "Observed P(Y=1)", col = "steelblue", lty = 1,
       cex = .7)
```

# Model with Judge Covariates (Party of Appointing President) 
```{r}
#| echo: TRUE
#| output: FALSE
#| message: FALSE
#| warning: FALSE  
#| cache: TRUE
# fixed/population-level effect 
# for party of appointing president
 
formula_2pl_cov <- bf(outcome ~ 1 + exp(logbeta)*eta,
                  eta ~ 1 + (1 |judge_id) + party_of_appointing_president, 
                  logbeta ~ 1 + (1 |case_id),
                  nl = TRUE)

priors_2pl_cov <- prior("normal(0, 3)" , class = "b", nlpar = "eta") +
  prior("normal(0, 3)", class = "b", nlpar = "logbeta")

brms_fit_2pl_cov <- brm(formula = formula_2pl_cov,
                   data = data,
                   prior = priors_2pl_cov,
                   family = "bernoulli",
                   backend = "cmdstanr",
                   cores = 4,
                   iter = 2000,
                   warmup = 1000)

qsave(x = brms_fit_2pl_cov, here("data", "brms_fit_2pl_cov.qs"))
```


```{r}
#| echo: TRUE
#| output: TRUE 
gt(get_prior(brms_fit_2pl_cov)) |> as_latex()
```

Rhat:

```{r}
#| echo: TRUE
rhat <- brms::rhat(brms_fit_2pl_cov) 
tibble(var = names(rhat), rhat = unname(rhat)) |>
  slice_max(rhat, n = 10)
```

Trace Plot:

```{r}
plot(brms_fit_2pl_cov, variable = c("b_eta_Intercept", 
"b_logbeta_Intercept", "b_eta_party_of_appointing_presidentRepublican"))
```

Posterior Predictive Check:

```{r}
#| echo: TRUE
y_2pl_cov <- mean(standata(brms_fit_2pl_cov)[["Y"]])
yrep_2pl_cov <- rowMeans(posterior_epred(brms_fit_2pl_cov))

hist(yrep_2pl_cov, main = "Posterior Predictive Check", 
xlab = "Posterior Predictive P(Y = 1) (4000 runs)")
abline(v = y_2pl_cov, col = "steelblue", lwd = 2)
legend("topright", legend = "Observed P(Y=1)", col = "steelblue", lty = 1,
       cex = .7)
```

# Model with Judge Covariates and Judge-Specific Intercept

```{r}
#| echo: TRUE
#| output: FALSE 
#| message: FALSE
#| warning: FALSE 
#| cache: TRUE
formula_2pl_in <- bf(outcome ~ 1 + exp(logbeta)*eta + alpha,
                  eta ~ 1 + (1 |judge_id) + party_of_appointing_president, 
                  logbeta ~ 1 + (1 |case_id),
                  alpha ~ (1 | case_id),
                  nl = TRUE)


priors_2pl_in <- prior("normal(0, 3)" , class = "b", nlpar = "eta") +
  prior("normal(0, 3)", class = "b", nlpar = "logbeta")

brms_fit_2pl_in <- brm(formula = formula_2pl_cov,
                   data = data,
                   prior = priors_2pl_in,
                   family = "bernoulli", 
                   backend = "cmdstanr",
                   cores = 4,
                   warmup = 1000,
                   iter = 2000)

qsave(x = brms_fit_2pl_cov, here("data", "brms_fit_2pl_in.qs"))
```


```{r}
#| echo: TRUE
#| output: TRUE 
gt(get_prior(brms_fit_2pl_in)) |> as_latex()
```

Rhat:
```{r}
#| echo: TRUE
rhat <- brms::rhat(brms_fit_2pl_in) 
tibble(var = names(rhat), rhat = unname(rhat)) |>
  slice_max(rhat, n = 10)
```

Trace Plot:

```{r}
plot(brms_fit_2pl_in, variable = c("b_eta_Intercept", "b_logbeta_Intercept",
"b_eta_party_of_appointing_presidentRepublican"))
```

Posterior Predictive Check:
```{r}
#| echo: TRUE
y_2pl_in <- mean(standata(brms_fit_2pl_in)[["Y"]])
yrep_2pl_in <- rowMeans(posterior_epred(brms_fit_2pl_in))

hist(yrep_2pl_in, main = "Posterior Predictive Check", 
xlab = "Posterior Predictive P(Y = 1) (4000 runs)")
abline(v = y_2pl_in, col = "steelblue", lwd = 2)
legend("topright", legend = "Observed P(Y=1)", col = "steelblue", lty = 1,
       cex = .7)
```
